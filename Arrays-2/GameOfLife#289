class Solution {
    
    // optimal solution
    // mutating the array
    // tn= O(M*N), SC = constant
    
    // 1 --> 0 = 7 // alive becoming dead.. alias is 7
    // 0 --> 1 = 8 // dead becoming alive.. alias is 8
    
    
    int m;
    int n;
    
    public void gameOfLife(int[][] board) {
        
        if(board == null || board.length==0) return;
        m = board.length;
        n = board[0].length;
        
        for(int i=0; i< board.length; i++){
            for(int j=0; j < board[0].length; j++){
                
                // find living neighbors
                int alive = findLiving(board, i, j);
                if(board[i][j] == 1){ // if it' alive
                    if(alive < 2 || alive > 3){ // rule 1 and 3
                        board[i][j] = 7;
                    }
                }else{
                    if(alive == 3){
                        board[i][j] = 8; // rule 4.. DEAD BECOMING ALIVE :O
                    }
                }
            }
        }
        
         for(int i=0; i< board.length; i++){
            for(int j=0; j < board[0].length; j++){
                
                if(board[i][j] == 7){
                    board[i][j] = 0;
                }else if(board[i][j]== 8){
                    board[i][j] = 1;
                }
            }
         }
        
    }
    
    private int findLiving( int[][] board, int i, int j){
        int count = 0; // counting alive cells
        
        // directions array
        int [][] dirs = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}};
        
        for(int[]dir: dirs){ // for each direction
            
            int r = i+dir[0];
            int c = j+dir[1];
            
            if( r >= 0 && c >=0 && r < m && c < n && (board[r][c] == 1 || board[r][c] == 7) ) {
                count ++;
            }
        }
        return count;
    }
}
